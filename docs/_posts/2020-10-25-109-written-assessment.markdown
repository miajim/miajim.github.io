In depth reflection on the RB109: Written Assessment 

*Exam Content*

- The exam was 21 questions long. I've heard it can vary from 20 - 23 questions, so be prepared for this. Questions varied in length, but most were just a few lines of code and on par with the code examples shown throughout the RB101 course (i.e., Christian Larwood's study guide).
- There are a handful of questions that ask you to thoroughly explain every line of code, but most questions will reference specific lines and/or provide what the code outputs and ask you to explain why the code returns and/or outputs what it does. So most of the time you will not need to write out a full explanation of each line of code for every problem. It's more important to be able to succinctly explain the underlying concept and use certain lines to demonstrate how the concept works.
- You have 3 hours to complete the exam. It took me 2 hrs 25 mins to write clear, complete answers to all 21 questions. I think I could've completed the exam in 2 hours if I had answered all questions without stopping to think about the exact phrasing I wanted to use and then circling back to "refactor" my responses in the remaining hour. But I am satisfied with the approach that I took and I still had 35 minutes to read through my work and check for formatting errors, etc. I submitted with 2 minutes remaining.
- Questions are grouped by topic (e.g., local variables, collections, etc.). I started in the middle of the exam with "collections" since this seemed like the longest portion and potentially the most challenging (i.e., would take the most brain power). I think this ended up being a good strategy and this left easier questions for the end.

*Logistics*

- I set an overall timer for 2 hrs 40 minutes (to allow for 15-20 minutes of review) with 40 minute interval timers (to confirm that I had completed at least 5 problems after each interval). I also wrote down the time that I started the exam, though this is visible to you at any time at the top of the assessment page. There are no timers built-in to the exam; you will **not** get a notification when you are nearing the end of the exam or when you've reached the end of the exam. It's up to you to keep track of your time!
- I kept track of the questions I answered fully on paper and made note of any I wanted to return to if I wasn't 100% satisfied with my initial answer. This was very helpful and gave me a good sense of how much of the exam I had completed as I was working through it.
- I was planning on writing my answer to a question in Notion and then copying it over into the answer box in the exam, because I had practiced using Markdown in Notion. However, when I tried this on the first question I answered, the markdown syntax did not copy over. So I wrote the answer in using markdown syntax on the exam and then copied the answer over into Notion as a backup.
- Once you submit the exam, the questions and your responses are saved and available for you to review at any time.

*Preparation*

- I spent two 25-27 hour weeks preparing for the written assessment. I felt like I had seen a lot of the technically precise language throughout 101, but I didn't spend any time using this language (especially not in written form) until I reached 109. I also didn't regularly study with others until 109, so I think all of these factors contributed to why I spent more time than I would've liked studying for the written assessment.
- I created an master checklist of everything I wanted to complete before taking the written assessment and then used this daily to guide what I spent time on, creating a "mini" task list for that day.
    - [ ]  Re-read through all links in the study guide
        - Take it slowly, understand each word
        - Make note of topics to review
    - [ ]  Make note of common phrases used to describe code/concepts
    - [ ]  Take notes on "Specific Topics of Interest"
        - Pay particular attention to #each, #map, #select (have exact definitions for each, understand what it does for different types of collections e.g., Hash vs. Array)
        - Pay particular attention to Array#sort
    - [ ]  Keep track of your questions and make sure you get answers to them (from other students, TAs, your own research, etc.)
    - [ ]  Go through all of Christian Larwood's examples
        - Write down timed solutions for each
        - Practice using pre-fabricated lines of code
        - Refactor answers and copy paste commonly used lines of code into repo
- In addition to attending two TA-led study sessions and a handful of group study sessions, I exchanged code snippets with a few students on Slack, responding to them when I could. Occasionally this would lead to a rabbit-hole, but for the most part, it was really helpful to receive feedback from others and it kept me actively practicing.
    - In some of the one-on-one study sessions with other students, we would spend most of our time on one or two short examples, first trying to come up with our own solutions, providing feedback on each other's solution, and then spent time refactoring our solution to be as precise as possible. This was also incredibly useful; I think instead of doing a mix of timed problems and untimed problems, I would've spent more time upfront not timing myself on problems to get the syntax right and extract commonly used phrases from those practice sessions and then being stricter about timing myself.
